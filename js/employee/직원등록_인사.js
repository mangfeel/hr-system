/**
 * 직원등록_인사.js - 프로덕션급 리팩토링
 * 
 * 신규 직원 등록 및 호봉 계산
 * - 직원 기본 정보 입력
 * - 과거 경력 관리 (추가/삭제)
 * - 호봉 자동 계산 (인정률 + 근무시간 비율)
 * - 첫승급일/차기승급일 계산
 * - 주 소정근로시간 관리 v3.2.0 추가
 * - 사원번호 자동생성 v3.3.0 추가
 * - 경력 없음 토글 v3.4.1 추가
 * - 발령 데이터 구조 통일 v3.4.2 추가
 * - 검증 및 저장
 * 
 * @version 4.3.0
 * @since 2024-11-04
 * 
 * [변경 이력]
 * v4.3.0 (2026-02-24) 입력 자동완성 추가
 * - 부서/직위/직급/직종 datalist 자동완성
 * - 기존 직원 데이터에서 고유값 추출하여 추천
 * - 직원 등록 후 목록 자동 갱신
 * - 인라인 자동완성: 후보 1개일 때 나머지 자동 채움
 *
 * v4.2.0 (2026-02-06) Electron 포커스 문제 해결
 * - 직원 등록 완료 후 window.focus() 호출
 * - 등록 후 입력란에 바로 커서가 들어가지 않는 문제 수정
 *
 * v4.1.0 (2026-01-22) 검증 API 연동
 * - Validator.validateEmployeeRegistration → API_인사.validateRegistration
 * - 서버 API로 검증 로직 보호
 * 
 * v4.0.0 (2026-01-21) API 연동 버전
 * - calculateAndSave() async 변경
 * - 호봉 계산 API 우선 사용 (API_인사)
 * - 서버 API로 계산 로직 보호
 * 
 * v3.4.2 (2025-12-10) 신규 발령 데이터 구조 개선
 * - 발령 ID: 숫자(1) → 문자열(assign-timestamp) 변경
 * - 발령 코드: '신규임용' → '고유번호-01' 패턴 (예: H105-01)
 * - startDate 필드 추가 (인사발령 모듈과 동일)
 * - paymentMethod, isRankBased, status 필드 추가
 * - 기존 date, type 필드는 하위 호환용으로 유지
 * 
 * v3.4.1 (2025-12-05) UI 개선 - 카드 통합 및 경력 없음 토글
 * - 6개 카드 → 3개 카드로 통합 (HTML 수정)
 * - toggleCareerSection() 함수 추가
 * - "경력 없음" 체크 시 경력 입력 폼 숨김
 * - resetRegisterForm()에 체크박스 초기화 추가
 * 
 * v3.4.0 (2025-12-05) 월소정근로시간 계산 공통화
 * - calculateMonthlyWorkingHours()가 SalaryCalculator.getMonthlyWorkingHours() 호출
 * - 급여설정의 소수점 처리 방식(올림/반올림/버림) 설정 반영
 * - fallback: SalaryCalculator 없을 시 반올림 처리
 * 
 * v3.3.0 (2025-12-04) 사원번호 자동생성 기능 추가
 * - updateEmployeeNumberField() 함수 추가
 * - 입사일 변경 시 사원번호 자동 업데이트
 * - 형식: YYYY-NNNN (입사 연도 기준)
 * - 빈 번호 재사용, 수동 입력 허용
 * 
 * v3.2.0 (2025-12-01) 주 소정근로시간 필드 추가 (급여 관리 대비)
 * - 직원 등록 시 "주 소정근로시간" 입력 필드 추가 (기본값 40시간)
 * - 월 소정근로시간 자동 계산 및 표시
 * - employment.weeklyWorkingHours에 저장
 * - 첫 번째 발령에 workingHours 저장
 * - calculateMonthlyWorkingHours() 함수 추가
 * - updateMonthlyHoursDisplay() 함수 추가
 * 
 * v3.1.0 (2025-11-26) 주당근무시간 비율 적용
 * - 경력 입력 폼에 "주당근무시간" 필드 추가 (1~40시간)
 * - 경력 계산 시 근무시간 비율 적용
 * - careerDetails에 workingHours 저장
 * - 환산공식: 실제기간 × (인정률/100) × (근무시간/40)
 * 
 * v3.0 - 프로덕션급 리팩토링
 * - Phase 1 유틸리티 적용 (DOM유틸, 직원유틸)
 * - 완벽한 에러 처리
 * - 체계적 로깅
 * - JSDoc 주석 추가
 * - XSS 방지
 * 
 * [하위 호환성]
 * - 모든 기존 함수명 유지
 * - 기존 API 100% 호환
 * - 전역 함수 유지
 * - 기존 직원 데이터: weeklyWorkingHours 없으면 기본값 40 적용
 * 
 * [의존성]
 * - 데이터베이스_인사.js (db)
 * - 검증_인사.js (Validator)
 * - 호봉계산기_인사.js (DateUtils, TenureCalculator, RankCalculator, CareerCalculator)
 * - DOM유틸_인사.js (DOM유틸_인사) - 선택
 * - 로거_인사.js (로거_인사) - 선택
 * - 에러처리_인사.js (에러처리_인사) - 선택
 */

// ===== 전역 변수 =====

/**
 * 추가된 경력 개수
 * @type {number}
 */
let careerCount = 0;

/**
 * 사원번호 자동생성 여부 플래그
 * @type {boolean}
 */
let _isEmployeeNumberAutoGenerated = true;

// ===== 초기화 함수 =====

/**
 * 고유번호 필드 업데이트
 * 다음 생성될 고유번호를 입력 필드에 표시
 * 
 * @example
 * updateUniqueCodeField(); // 'H042' 표시
 */
function updateUniqueCodeField() {
    try {
        로거_인사?.debug('고유번호 필드 업데이트');
        
        const uniqueCodeField = typeof DOM유틸_인사 !== 'undefined'
            ? DOM유틸_인사.getById('uniqueCode')
            : document.getElementById('uniqueCode');
        
        if (!uniqueCodeField) {
            로거_인사?.warn('고유번호 필드를 찾을 수 없음');
            return;
        }
        
        const nextCode = db.getNextUniqueCode();
        
        if (typeof DOM유틸_인사 !== 'undefined') {
            DOM유틸_인사.setValue(uniqueCodeField, nextCode);
        } else {
            uniqueCodeField.value = nextCode;
        }
        
        로거_인사?.debug('고유번호 필드 업데이트 완료', { nextCode });
        
    } catch (error) {
        로거_인사?.error('고유번호 필드 업데이트 실패', error);
        
        if (typeof 에러처리_인사 !== 'undefined') {
            에러처리_인사.handle(error, '고유번호 표시 중 오류가 발생했습니다.');
        }
    }
}

/**
 * 사원번호 필드 업데이트 (자동생성)
 * 입사일 연도 기준으로 사원번호 생성
 * 
 * @description
 * - 형식: YYYY-NNNN (예: 2026-0001)
 * - 입사일 변경 시 자동 호출
 * - 수동 입력 시 자동생성 비활성화
 * - 빈 번호 재사용 (삭제된 번호 중 가장 작은 것)
 * 
 * @example
 * updateEmployeeNumberField(); // 입사일 기준 사원번호 표시
 */
function updateEmployeeNumberField() {
    try {
        로거_인사?.debug('사원번호 필드 업데이트');
        
        const employeeNumberField = document.getElementById('employeeNumber');
        const entryDateField = document.getElementById('entryDate');
        
        if (!employeeNumberField || !entryDateField) {
            로거_인사?.warn('사원번호 또는 입사일 필드를 찾을 수 없음');
            return;
        }
        
 // 입사일이 없으면 처리 안 함
        const entryDate = entryDateField.value;
        if (!entryDate) {
            로거_인사?.debug('입사일 없음, 사원번호 업데이트 건너뜀');
            return;
        }
        
 // 자동생성 모드가 아니고 이미 값이 있으면 건너뜀
        const currentValue = employeeNumberField.value.trim();
        if (!_isEmployeeNumberAutoGenerated && currentValue) {
            로거_인사?.debug('수동 입력 모드, 사원번호 업데이트 건너뜀');
            return;
        }
        
 // 입사 연도 추출
        const entryYear = entryDate.substring(0, 4);
        
 // 사원번호 생성
        const newEmployeeNumber = db.generateEmployeeNumber(entryYear);
        
        employeeNumberField.value = newEmployeeNumber;
        _isEmployeeNumberAutoGenerated = true;
        
        로거_인사?.info('사원번호 자동생성 완료', {
            entryYear,
            employeeNumber: newEmployeeNumber
        });
        
    } catch (error) {
        로거_인사?.error('사원번호 필드 업데이트 실패', error);
        
        if (typeof 에러처리_인사 !== 'undefined') {
            에러처리_인사.handle(error, '사원번호 표시 중 오류가 발생했습니다.');
        }
    }
}

/**
 * 사원번호 수동 입력 처리
 * 사용자가 직접 입력하면 자동생성 비활성화
 * 
 * @example
 * // HTML: oninput="onEmployeeNumberInput()"
 */
function onEmployeeNumberInput() {
    _isEmployeeNumberAutoGenerated = false;
    로거_인사?.debug('사원번호 수동 입력 모드 전환');
}

/**
 * 사원번호 자동생성 버튼 클릭 처리
 * 
 * @example
 * // HTML: onclick="generateEmployeeNumberManual()"
 */
function generateEmployeeNumberManual() {
    try {
        const entryDateField = document.getElementById('entryDate');
        
        if (!entryDateField || !entryDateField.value) {
            const msg = '[주의] 먼저 입사일을 선택하세요.';
            if (typeof 에러처리_인사 !== 'undefined') {
                에러처리_인사.warn(msg);
            } else {
                alert(msg);
            }
            return;
        }
        
 // 자동생성 모드로 전환 후 업데이트
        _isEmployeeNumberAutoGenerated = true;
        updateEmployeeNumberField();
        
        로거_인사?.info('사원번호 수동 자동생성 완료');
        
    } catch (error) {
        로거_인사?.error('사원번호 수동 자동생성 실패', error);
    }
}

// ===== 경력 관리 함수 =====

/**
 * 경력 입력 폼 추가
 * 과거 경력을 입력할 수 있는 폼 섹션 동적 생성
 * 
 * @example
 * addCareer(); // 경력 입력 폼 추가
 */
function addCareer() {
    try {
        careerCount++;
        
        로거_인사?.debug('경력 추가', { careerCount });
        
        const careerList = typeof DOM유틸_인사 !== 'undefined'
            ? DOM유틸_인사.getById('careerList')
            : document.getElementById('careerList');
        
        if (!careerList) {
            로거_인사?.error('경력 목록 컨테이너를 찾을 수 없음');
            throw new Error('경력 목록을 찾을 수 없습니다.');
        }
        
 // 경력 폼 HTML 생성 (개선된 UI)
        const careerHTML = `
            <div class="career-header">
                <div class="career-title"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="17" x2="12" y2="22"/><path d="M5 17h14v-1.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V6h1a2 2 0 0 0 0-4H8a2 2 0 0 0 0 4h1v4.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24z"/></svg> 경력 ${careerCount}</div>
                <button class="btn btn-danger btn-small" onclick="removeCareer(${careerCount})" type="button">✕ 삭제</button>
            </div>
            <div class="form-group">
                <label>근무처/경력 내용</label>
                <input type="text" id="careerName-${careerCount}" class="form-control" placeholder="예: OO복지관, OO주간보호센터">
                <small class="form-hint">경력으로 인정될 기관명이나 업무내용을 입력하세요</small>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>시작일</label>
                    <input type="date" id="careerStartDate-${careerCount}" class="form-control">
                    <small class="form-hint">근무 시작일</small>
                </div>
                <div class="form-group">
                    <label>종료일</label>
                    <input type="date" id="careerEndDate-${careerCount}" class="form-control">
                    <small class="form-hint">근무 종료일</small>
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>인정률 (%)</label>
                    <input type="number" id="careerRate-${careerCount}" class="form-control" value="100" min="0" max="100" placeholder="100">
                    <small class="form-hint">동종업계 100%, 유사업종 80% 등</small>
                </div>
                <div class="form-group">
                    <label>주당근무시간</label>
                    <input type="number" id="careerWorkingHours-${careerCount}" class="form-control" value="40" min="1" max="40" placeholder="40">
                    <small class="form-hint">풀타임 40시간 기준 비율 적용</small>
                </div>
            </div>
        `;
        
 // DOM 생성
        const careerDiv = document.createElement('div');
        careerDiv.className = 'career-section';
        careerDiv.id = `career-${careerCount}`;
        careerDiv.innerHTML = careerHTML;
        
        careerList.appendChild(careerDiv);
        
        로거_인사?.info('경력 추가 완료', { careerCount });
        
    } catch (error) {
        로거_인사?.error('경력 추가 실패', error);
        
        if (typeof 에러처리_인사 !== 'undefined') {
            에러처리_인사.handle(error, '경력 추가 중 오류가 발생했습니다.');
        } else {
            alert('[오류] 경력 추가 중 오류가 발생했습니다.');
        }
    }
}

/**
 * 경력 입력 폼 삭제
 * 
 * @param {number} id - 삭제할 경력 ID
 * 
 * @example
 * removeCareer(1); // 경력 1 삭제
 */
function removeCareer(id) {
    try {
        로거_인사?.debug('경력 삭제 시도', { id });
        
        const career = document.getElementById(`career-${id}`);
        
        if (career) {
            career.remove();
            로거_인사?.info('경력 삭제 완료', { id });
        } else {
            로거_인사?.warn('삭제할 경력을 찾을 수 없음', { id });
        }
        
    } catch (error) {
        로거_인사?.error('경력 삭제 실패', error);
        
        if (typeof 에러처리_인사 !== 'undefined') {
            에러처리_인사.handle(error, '경력 삭제 중 오류가 발생했습니다.');
        }
    }
}

// ===== 메인 등록 함수 =====

/**
 * 호봉 계산 및 직원 정보 저장
 * 
 * 검증 단계:
 * 1. 필수 항목 검증
 * 2. 사원번호 중복 검증
 * 3. 과거 경력 날짜 검증
 * 4. 호봉 범위 검증
 * 5. 계산된 날짜 검증
 * 
 * @example
 * calculateAndSave(); // 폼 데이터 검증 및 저장
 */
async function calculateAndSave() {
    try {
        로거_인사?.info('직원 등록 시작');
        
 // ===== 입력값 수집 =====
        const getValue = (id) => {
            const elem = typeof DOM유틸_인사 !== 'undefined'
                ? DOM유틸_인사.getById(id)
                : document.getElementById(id);
            return elem ? (elem.value || '').trim() : '';
        };
        
        const name = getValue('employeeName');
        const employeeNumber = getValue('employeeNumber');
        const dept = getValue('employeeDept');
        const position = getValue('employeePosition');
        const grade = getValue('employeeGrade');
        const jobType = getValue('employeeJobType');
        const entryDate = getValue('entryDate');
        const employmentType = getValue('employmentType');
        
 // v3.2.0: 주 소정근로시간 추가
        const weeklyWorkingHoursValue = getValue('weeklyWorkingHours');
        const weeklyWorkingHours = parseInt(weeklyWorkingHoursValue) || 40;
        
        const isRankBasedElem = document.querySelector('input[name="isRankBased"]:checked');
        const isRankBased = isRankBasedElem ? isRankBasedElem.value === 'true' : false;
        
        로거_인사?.debug('입력값 수집 완료', {
            name,
            dept,
            position,
            entryDate,
            weeklyWorkingHours,
            isRankBased
        });
        
 // ===== 검증 1: 필수 항목 검증 (API) =====
        let validation;
        
 // API 검증 우선, fallback으로 로컬 검증
        if (typeof API_인사 !== 'undefined') {
            try {
 // 중복 검증을 위한 기존 코드 목록 수집
                const employees = db.data?.employees || [];
                const existingNumbers = employees
                    .filter(e => e.employeeNumber)
                    .map(e => e.employeeNumber);
                
                validation = await API_인사.validateRegistration(
                    { name, dept, position, grade, jobType, entryDate },
                    [],  // existingCodes (고유번호는 자동생성이므로 빈 배열)
                    existingNumbers
                );
                로거_인사?.debug('API 검증 완료', validation);
            } catch (apiError) {
                로거_인사?.warn('API 검증 실패, 로컬 검증 사용', apiError);
 // fallback: 로컬 검증
                validation = Validator.validateEmployeeRegistration({
                    name, dept, position, grade, jobType, entryDate
                });
            }
        } else {
 // API_인사 없으면 로컬 검증
            validation = Validator.validateEmployeeRegistration({
                name, dept, position, grade, jobType, entryDate
            });
        }
        
        if (!validation.valid) {
            로거_인사?.warn('필수 항목 검증 실패', { errors: validation.errors });
            
            const errorMsg = '[주의] 필수 항목을 입력하세요.\n\n' + validation.errors.join('\n');
            
            if (typeof 에러처리_인사 !== 'undefined') {
                에러처리_인사.warn(errorMsg);
            } else {
                alert(errorMsg);
            }
            return;
        }
        
 // ===== 검증 2: 사원번호 중복 검증 =====
        if (employeeNumber && db.isEmployeeNumberDuplicate(employeeNumber)) {
            로거_인사?.warn('사원번호 중복', { employeeNumber });
            
            const errorMsg = `[주의] 이미 사용 중인 사원번호입니다: ${employeeNumber}`;
            
            if (typeof 에러처리_인사 !== 'undefined') {
                에러처리_인사.warn(errorMsg);
            } else {
                alert(errorMsg);
            }
            return;
        }
        
 // ===== 경력 수집 =====
        const careers = [];
        
        for (let i = 1; i <= careerCount; i++) {
            const careerDiv = document.getElementById(`career-${i}`);
            if (!careerDiv) continue;
            
            const careerName = getValue(`careerName-${i}`);
            const careerStartDate = getValue(`careerStartDate-${i}`);
            const careerEndDate = getValue(`careerEndDate-${i}`);
            const careerRate = parseInt(getValue(`careerRate-${i}`)) || 100;
            const careerWorkingHours = parseInt(getValue(`careerWorkingHours-${i}`)) || 40;
            
 // 경력 내용이 있는 경우만 추가
            if (careerName && careerStartDate && careerEndDate) {
 // 검증 3: 경력 날짜 검증
                if (careerEndDate < careerStartDate) {
                    로거_인사?.warn('경력 날짜 오류', { careerName, careerStartDate, careerEndDate });
                    
                    const errorMsg = `[주의] 경력 "${careerName}"의 종료일이 시작일보다 빠릅니다.`;
                    
                    if (typeof 에러처리_인사 !== 'undefined') {
                        에러처리_인사.warn(errorMsg);
                    } else {
                        alert(errorMsg);
                    }
                    return;
                }
                
                careers.push({
                    name: careerName,
                    startDate: careerStartDate,
                    endDate: careerEndDate,
                    rate: careerRate,
                    workingHours: careerWorkingHours
                });
            }
        }
        
        로거_인사?.debug('경력 수집 완료', { careerCount: careers.length });
        
 // ===== 호봉 계산 =====
        로거_인사?.debug('호봉 계산 시작');
        
 // 경력 계산
        const careerResult = CareerCalculator.calculateTotalCareer(careers);
        const totalYears = careerResult.totalYears || 0;
        const totalMonths = careerResult.totalMonths || 0;
        const totalDays = careerResult.totalDays || 0;
        
        로거_인사?.debug('경력 계산 완료', { totalYears, totalMonths, totalDays });
        
 // v4.0.0: 입사 호봉 계산 - API 우선 사용
        let currentGrade;
        if (typeof API_인사 !== 'undefined') {
            currentGrade = await API_인사.calculateInitialRank(totalYears, totalMonths);
        } else {
            currentGrade = RankCalculator.calculateInitialRank(totalYears, totalMonths);
        }
        
        로거_인사?.debug('입사 호봉 계산 완료', { currentGrade });
        
 // 검증 4: 호봉 범위 검증
        const minRank = typeof CONFIG !== 'undefined' ? CONFIG.RANK.MIN : 1;
        const maxRank = typeof CONFIG !== 'undefined' ? CONFIG.RANK.MAX : 99;
        
        if (currentGrade < minRank || currentGrade > maxRank) {
            로거_인사?.warn('호봉 범위 초과', { currentGrade, minRank, maxRank });
            
            const errorMsg = `[주의] 계산된 호봉(${currentGrade})이 허용 범위(${minRank}~${maxRank})를 벗어났습니다.`;
            
            if (typeof 에러처리_인사 !== 'undefined') {
                에러처리_인사.warn(errorMsg);
            } else {
                alert(errorMsg);
            }
            return;
        }
        
 // v4.0.0: 첫승급일 계산 - API 우선 사용
        let firstUpgradeDate;
        if (typeof API_인사 !== 'undefined') {
            firstUpgradeDate = await API_인사.calculateFirstUpgradeDate(
                entryDate, totalYears, totalMonths, totalDays
            );
        } else {
            firstUpgradeDate = RankCalculator.calculateFirstUpgradeDate(
                entryDate, totalYears, totalMonths, totalDays
            );
        }
        
        로거_인사?.debug('첫승급일 계산 완료', { firstUpgradeDate });
        
 // v4.0.0: 차기승급일 계산 - API 우선 사용
 // 기준일은 오늘 날짜 사용
        const today = new Date().toISOString().split('T')[0];
        let nextUpgradeDate;
        if (typeof API_인사 !== 'undefined') {
            nextUpgradeDate = await API_인사.calculateNextUpgradeDate(firstUpgradeDate, today);
        } else {
            nextUpgradeDate = RankCalculator.calculateNextUpgradeDate(firstUpgradeDate, today);
        }
        
        로거_인사?.debug('차기승급일 계산 완료', { nextUpgradeDate });
        
 // 검증 5: 계산된 날짜 검증
        if (isRankBased && (!firstUpgradeDate || !nextUpgradeDate)) {
            로거_인사?.warn('승급일 계산 실패');
            
            const errorMsg = '[주의] 승급일 계산에 실패했습니다.\n입력값을 확인하세요.';
            
            if (typeof 에러처리_인사 !== 'undefined') {
                에러처리_인사.warn(errorMsg);
            } else {
                alert(errorMsg);
            }
            return;
        }
        
 // ===== 직원 데이터 생성 =====
        const uniqueCode = db.generateUniqueCode();
        
        const employee = {
            id: crypto.randomUUID ? crypto.randomUUID() : Date.now().toString(),
            uniqueCode: uniqueCode,
            employeeNumber: employeeNumber || '',
            
            personalInfo: {
                name: name
            },
            
            employment: {
                dept: dept,
                position: position,
                grade: grade || '',
                jobType: jobType || '',
                entryDate: entryDate,
                employmentType: employmentType || '정규직',
                isRankBased: isRankBased,
                weeklyWorkingHours: weeklyWorkingHours
            },
            
            rank: isRankBased ? {
                startRank: currentGrade,      // ⭐ 입사 시 획정 호봉
                currentRank: currentGrade,
                firstUpgradeDate: firstUpgradeDate,
                nextUpgradeDate: nextUpgradeDate
            } : null,
            
            career: {
                totalYears: totalYears,
                totalMonths: totalMonths,
                totalDays: totalDays
            },
            
            careerDetails: (careerResult.details || []).map((d, idx) => ({
                id: idx + 1,
                name: d.name,
                startDate: d.startDate,
                endDate: d.endDate,
                rate: d.rate,
                workingHours: d.workingHours,
 // 연명부 호환용 문자열 필드 추가
                period: d.originalPeriod 
                    ? `${d.originalPeriod.years}년 ${d.originalPeriod.months}개월 ${d.originalPeriod.days}일` 
                    : '',
                converted: d.convertedPeriod 
                    ? `${d.convertedPeriod.years}년 ${d.convertedPeriod.months}개월 ${d.convertedPeriod.days}일` 
                    : ''
            })),
            
 // 첫 번째 발령 기록 생성 - v3.4.2: 인사발령 모듈과 일관된 구조
            assignments: [{
                id: `assign-${Date.now()}`,  // ⭐ 문자열 ID로 통일
                code: `${uniqueCode}-01`,    // ⭐ 발령 코드 패턴: 고유번호-순번
                startDate: entryDate,        // ⭐ 인사발령 모듈과 동일 필드명
                date: entryDate,             // 하위 호환용
                type: '신규임용',             // 발령 유형
                dept: dept,
                position: position,
                grade: grade || '',
                rank: isRankBased ? currentGrade : null,
                workingHours: weeklyWorkingHours,
                paymentMethod: isRankBased ? '호봉제' : '연봉제',  // ⭐ 급여방식 추가
                isRankBased: isRankBased,    // ⭐ 호봉제 여부 추가
                note: '신규 입사',
                status: 'active'             // ⭐ 현재 발령 상태
            }],
            
            currentPosition: {
                dept: dept,
                position: position,
                grade: grade || '',
                assignmentDate: entryDate
            }
        };
        
        로거_인사?.debug('직원 데이터 생성 완료', {
            uniqueCode,
            name,
            currentGrade
        });
        
 // ===== 저장 =====
        db.saveEmployee(employee);
        
        로거_인사?.info('직원 등록 완료', {
            uniqueCode,
            employeeNumber,
            name,
            dept,
            position,
            currentGrade
        });
        
 // 성공 메시지
        const successMsg = `${name}님이 등록되었습니다.\n\n` +
            `고유번호: ${uniqueCode}\n` +
            (employeeNumber ? `사원번호: ${employeeNumber}\n` : '') +
            `입사일: ${entryDate}\n` +
            (isRankBased ? `입사 호봉: ${currentGrade}호봉` : '');
        
        if (typeof 에러처리_인사 !== 'undefined') {
            에러처리_인사.success(successMsg);
        } else {
            alert(successMsg);
        }
        
 // 결과 표시
        displayCalculationResult(
            name, totalYears, totalMonths, totalDays,
            currentGrade, firstUpgradeDate, nextUpgradeDate,
            careerResult.details || [], isRankBased
        );
        
 // 대시보드 업데이트
        if (typeof updateDashboard === 'function') {
            updateDashboard();
        }
        updateUniqueCodeField();
        
 // 자동완성 목록 갱신 (새 부서/직위가 추가되었을 수 있음)
        if (typeof updateAutocompleteLists === 'function') {
            updateAutocompleteLists();
        }
        
 // 폼 초기화
        resetRegisterForm();
        
 // v4.2.0: 윈도우 포커스 복원 (Electron 포커스 문제 해결)
 // blur/focus 트릭 후 입력란에 포커스
        const focusInput = async () => {
            if (window.electronAPI?.focusWindow) {
                await window.electronAPI.focusWindow();
 // blur/focus 완료 후 입력란에 포커스
                setTimeout(() => {
                    const nameInput = document.getElementById('employeeName');
                    if (nameInput) nameInput.focus();
                }, 100);
            }
        };
        setTimeout(focusInput, 500);
        setTimeout(focusInput, 2000);
        
    } catch (error) {
        로거_인사?.error('직원 등록 실패', error);
        
        if (typeof 에러처리_인사 !== 'undefined') {
            에러처리_인사.handle(error, '직원 등록 중 오류가 발생했습니다.');
        } else {
            alert('[오류] 직원 등록 중 오류가 발생했습니다.');
        }
    }
}

// ===== 폼 관리 함수 =====

/**
 * 등록 폼 초기화
 * 모든 입력 필드를 기본값으로 리셋
 * 
 * @example
 * resetRegisterForm(); // 폼 초기화
 */
function resetRegisterForm() {
    try {
        로거_인사?.debug('등록 폼 초기화 시작');
        
        const setValue = (id, value) => {
            const elem = typeof DOM유틸_인사 !== 'undefined'
                ? DOM유틸_인사.getById(id)
                : document.getElementById(id);
            if (elem) {
                if (typeof DOM유틸_인사 !== 'undefined') {
                    DOM유틸_인사.setValue(elem, value);
                } else {
                    elem.value = value;
                }
            }
        };
        
        setValue('employeeName', '');
        setValue('employeeNumber', '');
        setValue('employeeDept', '');
        setValue('employeePosition', '');
        setValue('employeeGrade', '');
        setValue('employeeJobType', '');
        setValue('entryDate', DateUtils.formatDate(new Date()));
        
 // v3.2.0: 주 소정근로시간 초기화
        setValue('weeklyWorkingHours', '40');
        setValue('monthlyWorkingHoursDisplay', '209시간');
        
 // v3.3.0: 사원번호 자동생성 모드 리셋 및 업데이트
        _isEmployeeNumberAutoGenerated = true;
        updateEmployeeNumberField();
        
 // v3.4.1: 경력 없음 체크박스 초기화
        const noCareerCheckbox = document.getElementById('noCareerCheckbox');
        const careerSection = document.getElementById('careerSection');
        if (noCareerCheckbox) {
            noCareerCheckbox.checked = false;
        }
        if (careerSection) {
            careerSection.classList.remove('hidden');
        }
        
 // 경력 목록 초기화
        const careerList = typeof DOM유틸_인사 !== 'undefined'
            ? DOM유틸_인사.getById('careerList')
            : document.getElementById('careerList');
        
        if (careerList) {
            careerList.innerHTML = '';
        }
        
        careerCount = 0;
        addCareer();
        
        로거_인사?.info('등록 폼 초기화 완료');
        
    } catch (error) {
        로거_인사?.error('등록 폼 초기화 실패', error);
    }
}

// ===== 결과 표시 함수 =====

/**
 * 계산 결과 표시
 * 호봉 계산 결과를 UI에 표시
 * 
 * @param {string} name - 직원 이름
 * @param {number} years - 환산 경력 (년)
 * @param {number} months - 환산 경력 (월)
 * @param {number} days - 환산 경력 (일)
 * @param {number} currentGrade - 입사 호봉
 * @param {string} firstUpgradeDate - 첫승급일
 * @param {string} nextDate - 차기승급일
 * @param {Array} details - 경력 상세 배열
 * @param {boolean} isRankBased - 호봉제 여부
 */
function displayCalculationResult(name, years, months, days, currentGrade, firstUpgradeDate, nextDate, details, isRankBased) {
    try {
        로거_인사?.debug('계산 결과 표시 시작', { name, currentGrade });
        
 // 호봉획정표 출력용 데이터 저장
        window.lastCalculationData = {
            name: name,
            dept: document.getElementById('employeeDept')?.value || '-',
            position: document.getElementById('employeePosition')?.value || '-',
            entryDate: document.getElementById('entryDate')?.value || '-',
            years: years,
            months: months,
            days: days,
            startRank: currentGrade,      // 입사 시 획정 호봉
            currentRank: currentGrade,    // 현재 호봉 (신규 등록이므로 동일)
            firstUpgradeDate: firstUpgradeDate,
            nextUpgradeDate: nextDate,
            careerDetails: details.map((d, idx) => ({
                id: idx + 1,
                name: d.name || '미입력',
                startDate: d.startDate || '',
                endDate: d.endDate || '',
                rate: d.rate || 100,
                workingHours: d.workingHours || 40,
 // 원본 기간과 환산 기간 정보 추가
                originalPeriod: d.originalPeriod || null,
                convertedPeriod: d.convertedPeriod || null
            }))
        };
        로거_인사?.debug('호봉획정표 출력용 데이터 저장 완료', window.lastCalculationData);
        
        const resultBox = typeof DOM유틸_인사 !== 'undefined'
            ? DOM유틸_인사.getById('rankResult')
            : document.getElementById('rankResult');
        
        if (!resultBox) {
            로거_인사?.warn('결과 표시 영역을 찾을 수 없음');
            return;
        }
        
 // 경력 상세 HTML 생성
        let detailsHTML = '';
        if (details.length > 0) {
            details.forEach(d => {
 // XSS 방지
                const safeName = typeof DOM유틸_인사 !== 'undefined'
                    ? DOM유틸_인사.escapeHtml(d.name)
                    : d.name;
                
 // 기간 표시 형식 처리
                const periodStr = d.originalPeriod 
                    ? `${d.originalPeriod.years}년 ${d.originalPeriod.months}개월 ${d.originalPeriod.days}일`
                    : (d.period || '-');
                const convertedStr = d.convertedPeriod
                    ? `${d.convertedPeriod.years}년 ${d.convertedPeriod.months}개월 ${d.convertedPeriod.days}일`
                    : (d.converted || '-');
                
                detailsHTML += `
                    <div style="background: white; border: 1.5px solid #e8ebed; padding: 18px; border-radius: 12px; margin-bottom: 12px;">
                        <div style="font-weight: 600; margin-bottom: 8px; color: #1a1d1f; font-size: 15px;">${safeName}</div>
                        <div style="font-size: 13px; color: #6b7280; line-height: 1.6;">
                            실제 근무기간: ${periodStr}
                            <br>→ 인정률 ${d.rate || 100}% 적용: <span style="color: #4f46e5; font-weight: 600;">${convertedStr}</span>
                        </div>
                    </div>
                `;
            });
        }
        
 // XSS 방지
        const safeName = typeof DOM유틸_인사 !== 'undefined'
            ? DOM유틸_인사.escapeHtml(name)
            : name;
        
 // 결과 HTML 생성
        const resultHTML = `
            <div class="result-box">
                <h2 style="margin-bottom: 8px; font-size: 22px; font-weight: 600; color: #1a1d1f;"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/></svg> 호봉 계산 결과</h2>
                <p style="color: #6b7280; margin-bottom: 24px; font-size: 14px;">${safeName}</p>
                
                ${detailsHTML}
                
                <div class="result-grid">
                    <div class="result-item">
                        <div class="result-label">환산 총 경력</div>
                        <div class="result-value">${years}<span class="result-unit">년</span> ${months}<span class="result-unit">개월</span> ${days}<span class="result-unit">일</span></div>
                    </div>
                    <div class="result-item highlight">
                        <div class="result-label">입사 호봉</div>
                        <div class="result-value">${currentGrade}<span class="result-unit">호봉</span></div>
                    </div>
                    ${isRankBased ? `
                    <div class="result-item highlight">
                        <div class="result-label">첫승급일</div>
                        <div class="result-value" style="font-size: 20px;">${firstUpgradeDate}</div>
                    </div>
                    <div class="result-item highlight">
                        <div class="result-label">차기 승급일</div>
                        <div class="result-value" style="font-size: 20px;">${nextDate}</div>
                    </div>
                    ` : ''}
                </div>
                <div style="margin-top: 24px; text-align: center;">
                    <button class="btn btn-primary" onclick="showCertificateFromResult()"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg> 호봉획정표 출력</button>
                </div>
            </div>
        `;
        
        resultBox.innerHTML = resultHTML;
        
        if (typeof DOM유틸_인사 !== 'undefined') {
            DOM유틸_인사.show(resultBox);
        } else {
            resultBox.style.display = 'block';
        }
        
        resultBox.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        
        로거_인사?.info('계산 결과 표시 완료');
        
    } catch (error) {
        로거_인사?.error('계산 결과 표시 실패', error);
        
        if (typeof 에러처리_인사 !== 'undefined') {
            에러처리_인사.handle(error, '결과 표시 중 오류가 발생했습니다.');
        }
    }
}

// ===== 모듈 로드 완료 =====

로거_인사?.info('직원등록 모듈 로드 완료');

// ===== v3.2.0 추가: 월 소정근로시간 계산 함수 =====
// ===== v3.3.0 수정: SalaryCalculator 공통 함수 사용 =====

/**
 * 월 소정근로시간 계산
 * 
 * @param {number} weeklyHours - 주 소정근로시간
 * @param {number} year - 연도 (소수점 처리 설정 참조용)
 * @returns {number} 월 소정근로시간
 * 
 * @description
 * 공식: (주 근무시간 + 주휴시간) × (365 ÷ 12 ÷ 7)
 * - 주휴시간 = 주 근무시간 ÷ 40 × 8 (주 15시간 이상 근무 시)
 * - 주 15시간 미만: 주휴수당 없음
 * - 소수점 처리: 급여설정에서 지정 (올림/반올림/버림)
 * 
 * @example
 * calculateMonthlyWorkingHours(40); // 반올림 → 209
 * calculateMonthlyWorkingHours(25); // 반올림 → 130
 * calculateMonthlyWorkingHours(35); // 반올림 → 183
 */
function calculateMonthlyWorkingHours(weeklyHours, year = null) {
    try {
 // SalaryCalculator가 로드되어 있으면 공통 함수 사용
        if (typeof SalaryCalculator !== 'undefined' && SalaryCalculator.getMonthlyWorkingHours) {
            return SalaryCalculator.getMonthlyWorkingHours(weeklyHours, year);
        }
        
 // fallback: SalaryCalculator가 없는 경우 직접 계산 (반올림)
        const hours = parseInt(weeklyHours) || 40;
        const weeksPerMonth = 365 / 7 / 12;  // 4.345238...
        
        if (hours < 15) {
            return Math.round(hours * weeksPerMonth);
        }
        
        const weeklyRestHours = (hours / 40) * 8;
        return Math.round((hours + weeklyRestHours) * weeksPerMonth);
        
    } catch (error) {
        로거_인사?.error('월 소정근로시간 계산 실패', error);
        return 209; // 기본값
    }
}

/**
 * 월 소정근로시간 표시 업데이트
 * 
 * @description
 * 주 소정근로시간 입력 시 월 소정근로시간을 자동 계산하여 표시합니다.
 * 
 * @example
 * // HTML: onchange="updateMonthlyHoursDisplay()"
 */
function updateMonthlyHoursDisplay() {
    try {
        const weeklyHoursElem = document.getElementById('weeklyWorkingHours');
        const monthlyDisplayElem = document.getElementById('monthlyWorkingHoursDisplay');
        
        if (!weeklyHoursElem || !monthlyDisplayElem) {
            로거_인사?.warn('월 소정근로시간 표시 요소를 찾을 수 없음');
            return;
        }
        
        const weeklyHours = parseInt(weeklyHoursElem.value) || 40;
        const monthlyHours = calculateMonthlyWorkingHours(weeklyHours);
        
        monthlyDisplayElem.value = monthlyHours + '시간';
        
        로거_인사?.debug('월 소정근로시간 표시 업데이트', {
            weeklyHours,
            monthlyHours
        });
        
    } catch (error) {
        로거_인사?.error('월 소정근로시간 표시 업데이트 실패', error);
    }
}

// ===== v3.4.1 추가: 경력 없음 토글 =====

/**
 * 경력 섹션 표시/숨김 토글
 * "경력 없음" 체크박스 상태에 따라 경력 입력 폼을 숨기거나 표시
 * 
 * @example
 * // HTML: onchange="toggleCareerSection()"
 */
function toggleCareerSection() {
    try {
        const checkbox = document.getElementById('noCareerCheckbox');
        const careerSection = document.getElementById('careerSection');
        
        if (!checkbox || !careerSection) {
            로거_인사?.warn('경력 섹션 요소를 찾을 수 없음');
            return;
        }
        
        if (checkbox.checked) {
            careerSection.classList.add('hidden');
            로거_인사?.debug('경력 섹션 숨김 (경력 없음 선택)');
        } else {
            careerSection.classList.remove('hidden');
            로거_인사?.debug('경력 섹션 표시');
        }
        
    } catch (error) {
        로거_인사?.error('경력 섹션 토글 실패', error);
    }
}

// ===== 입력 자동완성 (datalist) =====

/**
 * 부서/직위/직급/직종 자동완성 목록 갱신
 * - 기존 직원 데이터에서 고유값 추출
 * - <datalist>에 option으로 채움
 * - 직원등록/인사발령 공용
 */
function updateAutocompleteLists() {
    try {
        if (typeof db === 'undefined' || !db) return;
        
        const employees = db.getEmployees();
        if (!employees || employees.length === 0) return;
        
        const deptSet = new Set();
        const positionSet = new Set();
        const gradeSet = new Set();
        const jobTypeSet = new Set();
        
        employees.forEach(emp => {
            // 현재 정보 (employment)
            if (emp.employment?.dept) deptSet.add(emp.employment.dept);
            if (emp.employment?.position) positionSet.add(emp.employment.position);
            if (emp.employment?.grade) gradeSet.add(emp.employment.grade);
            if (emp.employment?.jobType) jobTypeSet.add(emp.employment.jobType);
            
            // currentPosition (최신 발령 반영)
            if (emp.currentPosition?.dept) deptSet.add(emp.currentPosition.dept);
            if (emp.currentPosition?.position) positionSet.add(emp.currentPosition.position);
            if (emp.currentPosition?.grade) gradeSet.add(emp.currentPosition.grade);
            if (emp.currentPosition?.jobType) jobTypeSet.add(emp.currentPosition.jobType);
            
            // 발령 이력
            if (emp.assignments && Array.isArray(emp.assignments)) {
                emp.assignments.forEach(a => {
                    if (a.dept) deptSet.add(a.dept);
                    if (a.department) deptSet.add(a.department);
                    if (a.position) positionSet.add(a.position);
                    if (a.grade) gradeSet.add(a.grade);
                });
            }
        });
        
        _fillDatalist('autolist-dept', deptSet);
        _fillDatalist('autolist-position', positionSet);
        _fillDatalist('autolist-grade', gradeSet);
        _fillDatalist('autolist-jobtype', jobTypeSet);
        
        로거_인사?.debug('자동완성 목록 갱신', {
            부서: deptSet.size, 직위: positionSet.size,
            직급: gradeSet.size, 직종: jobTypeSet.size
        });
        
    } catch (error) {
        로거_인사?.error('자동완성 목록 갱신 실패', error);
    }
}

/**
 * datalist에 option 채우기
 * @param {string} datalistId - datalist 요소 ID
 * @param {Set} valueSet - 고유값 Set
 */
function _fillDatalist(datalistId, valueSet) {
    const datalist = document.getElementById(datalistId);
    if (!datalist) return;
    
    datalist.innerHTML = '';
    const sorted = Array.from(valueSet)
        .filter(v => v && v.trim())
        .sort((a, b) => a.localeCompare(b, 'ko'));
    sorted.forEach(val => {
        const option = document.createElement('option');
        option.value = val;
        datalist.appendChild(option);
    });
}

// 앱 시작 시 자동완성 목록 초기화 (DB 로드 후)
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        if (typeof updateAutocompleteLists === 'function') {
            updateAutocompleteLists();
        }
        _initInlineAutocomplete();
    }, 2000);
});

// ===== 인라인 자동완성 (후보 1개일 때 자동 채움) =====

/**
 * 인라인 자동완성 초기화
 * - 대상 input에 이벤트 리스너 등록
 * - 직원등록 + 인사발령 공용
 */
function _initInlineAutocomplete() {
    const targetIds = [
        'employeeDept', 'employeePosition', 'employeeGrade', 'employeeJobType',
        'assignmentDept', 'assignmentPosition', 'assignmentGrade'
    ];
    
    targetIds.forEach(id => {
        const input = document.getElementById(id);
        if (!input) return;
        
        input._isComposing = false;
        input._suppressAutocomplete = false;
        
        // 백스페이스/Delete/방향키 등에서는 자동완성 억제
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // 자동완성된 부분 제거: 선택 영역 앞까지만 유지
                const cursorPos = input.selectionStart;
                if (input.selectionStart !== input.selectionEnd) {
                    input.value = input.value.substring(0, cursorPos);
                }
                input._suppressAutocomplete = true;
            } else if (e.key === 'Backspace' || e.key === 'Delete' || 
                e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                input._suppressAutocomplete = true;
            }
        });
        
        // 입력 시 인라인 자동완성
        input.addEventListener('input', _handleInlineAutocomplete);
        
        // 한글 조합 중에는 자동완성 방지
        input.addEventListener('compositionstart', () => {
            input._isComposing = true;
        });
        input.addEventListener('compositionend', (e) => {
            input._isComposing = false;
            if (input._suppressAutocomplete) {
                input._suppressAutocomplete = false;
                return;
            }
            _handleInlineAutocomplete(e);
        });
    });
    
    로거_인사?.debug('인라인 자동완성 초기화 완료');
}

/**
 * 인라인 자동완성 핸들러
 * - datalist에서 현재 입력값과 매칭되는 후보 검색
 * - 후보가 1개면 나머지를 자동 채우고 선택 영역으로 표시
 */
function _handleInlineAutocomplete(e) {
    const input = e.target;
    
    // 한글 조합 중이면 무시
    if (input._isComposing) return;
    
    // 삭제/방향키 등이면 무시하고 플래그 리셋
    if (input._suppressAutocomplete) {
        input._suppressAutocomplete = false;
        return;
    }
    
    const typed = input.value;
    if (!typed || typed.length === 0) return;
    
    // 이미 선택 영역이 있으면 사용자가 입력한 부분만 추출
    const cursorPos = input.selectionStart;
    const actualTyped = typed.substring(0, cursorPos);
    if (!actualTyped || actualTyped.length === 0) return;
    
    // 연결된 datalist에서 후보 검색
    const datalistId = input.getAttribute('list');
    if (!datalistId) return;
    
    const datalist = document.getElementById(datalistId);
    if (!datalist) return;
    
    const options = Array.from(datalist.options).map(o => o.value);
    
    // 입력값으로 시작하는 후보 필터링
    const matches = options.filter(opt => 
        opt.startsWith(actualTyped) && opt !== actualTyped
    );
    
    // 후보가 정확히 1개일 때만 자동 채움
    if (matches.length === 1) {
        const fullValue = matches[0];
        input.value = fullValue;
        input.setSelectionRange(actualTyped.length, fullValue.length);
    }
}
